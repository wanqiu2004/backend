Spring Framework 最初包含的 Web 框架 Spring Web MVC 是专门为 Servlet API 和 Servlet 容器设计的。在 5.0 版本中，新增了响应式栈 Web 框架 SpringWebFlux。该框架完全非阻塞，支持 Reactive Streams 的背压机制，并能够运行在诸如Netty、Undertow 以及 Servlet 容器等服务器上。

这两个 Web 框架与其源模块的名称相对应（分别为 spring-webmvc 和 spring-webflux），并在 Spring Framework 中并存。每个模块都是可选的。应用程序可以使用其中一个模块，或者在某些情况下同时使用两者，例如，可以将 Spring MVC 控制器与响应式 WebClient 结合使用。

为什么创建 Spring WebFlux？

部分原因是对非阻塞 Web 栈的需求，以便通过少量线程处理并发，并以更少的硬件资源实现扩展。Servlet 的非阻塞 I/O 与 Servlet API 的其他部分渐行渐远，因为其契约是同步的（如 Filter、Servlet）或阻塞的（如 getParameter、getPart）。这促使了开发一个新的通用 API，作为任何非阻塞运行时的基础。这一点尤为重要，因为像 Netty 这样的服务器已经在异步、非阻塞领域占据了重要地位。

回答的另一部分与函数式编程有关。正如 Java 5 中注解的加入创造了机遇（如注解式的 REST 控制器或单元测试），Java 8 中 lambda 表达式的加入为 Java 中的函数式 API 提供了机会。这对于非阻塞应用程序和延续风格的 API（如同 CompletableFuture 和 ReactiveX 所推广的那样，允许以声明方式组合异步逻辑）来说是一大福音。在编程模型层面上，Java 8 使得 Spring WebFlux 能够提供函数式 web 端点以及注解控制器。这一进展不仅丰富了开发者的工具箱，也为更高效、更简洁的代码实现提供了可能。

还有另一个重要的机制，我们 Spring 团队将其与“响应式”联系在一起，那就是**非阻塞背压（non-blocking back pressure）**。在同步、命令式代码中，阻塞调用是一种天然的背压形式，它迫使调用方等待。而在非阻塞代码中，控制事件的速率变得尤为重要，以防止快速的生产者压垮其目标消费者。

背压机制的核心在于允许消费者通过反馈机制告知生产者其处理能力的限制，从而避免系统过载。这种机制在响应式编程中尤为重要，因为响应式流（Reactive Streams）规范定义了如何在异步、非阻塞的环境中安全地传递数据流，同时确保生产者和消费者之间的协调。通过这种方式，响应式系统能够在高并发场景下保持高效和稳定，而不会因资源耗尽或数据堆积而导致崩溃。

Reactive Streams 是一个小型规范（也被 Java 9 采纳），它定义了具有背压机制的异步组件之间的交互方式。例如，一个数据存储库（作为发布者 Publisher）可以生成数据，而一个 HTTP 服务器（作为订阅者 Subscriber）随后可以将这些数据写入响应中。Reactive Streams 的主要目的是让订阅者能够控制发布者生产数据的速度——无论是更快还是更慢。

**常见问题：如果发布者无法减缓生产速度怎么办？**

Reactive Streams 的目的仅仅是建立一种机制和边界。如果发布者无法减缓生产速度，它必须决定采取何种策略来应对：是缓冲数据、丢弃数据，还是直接失败。这种灵活性使得系统能够在不同的场景下选择最适合的处理方式，从而在性能和稳定性之间找到平衡。

### 响应式 API

Reactive Streams 在互操作性方面发挥了重要作用。它对库和基础设施组件来说具有重要意义，但作为应用层 API 的实用性较低，因为它的抽象层次较低。应用程序需要更高级、更丰富且功能强大的 API 来组合异步逻辑——类似于 Java 8 的 Stream API，但不仅限于集合操作。而这正是响应式库所扮演的角色。

这些响应式库通过提供更直观、更高层次的抽象，使得开发者能够以声明式的方式编写复杂的异步逻辑，同时隐藏底层实现的复杂性。这样不仅提高了代码的可读性和可维护性，还简化了异步流的处理过程，从而使开发者能够专注于业务逻辑本身，而不是底层的线程管理和背压控制。

Reactor 是 Spring WebFlux 的首选响应式库。它提供了 `Mono` 和 `Flux` 两种 API 类型，用于处理数据序列：`Mono` 表示包含 0 或 1 个元素的数据序列，而 `Flux` 表示包含 0 到 N 个元素的数据序列。这些 API 提供了一组丰富的操作符，与 ReactiveX 的操作符词汇表保持一致。作为 Reactive Streams 规范的实现，Reactor 的所有操作符都支持非阻塞背压（non-blocking back pressure）。

Reactor 在服务器端 Java 开发中具有高度的关注点，并且与 Spring 框架紧密协作开发。这种深度集成使得 Reactor 成为 Spring WebFlux 的核心组件之一，为开发者提供了一个强大且高效的工具来构建响应式应用程序。通过 Reactor，开发者能够以声明式的方式处理异步数据流，同时确保系统的高性能和稳定性。

WebFlux 确实依赖 Reactor 作为其核心库，但通过 Reactive Streams 规范，它也能够与其他响应式库实现互操作。通常情况下，WebFlux API 接受一个普通的 `Publisher` 作为输入，在内部将其适配为 Reactor 类型（如 `Flux` 或 `Mono`），进行必要的处理后，再返回一个 `Flux` 或 `Mono` 作为输出。这意味着你可以传递任何实现了 `Publisher` 接口的对象作为输入，并在输出上应用各种操作。然而，如果需要将输出与另一个响应式库一起使用，则可能需要进行相应的适配。

在可行的情况下（例如在注解控制器中），WebFlux 可以透明地适应 RxJava 或其他响应式库的使用。有关更多细节，请参阅 Reactive Libraries 相关文档。除了支持响应式 API 外，WebFlux 还可以与 Kotlin 的协程（Coroutines）API 一起使用，这为开发者提供了更接近命令式的编程风格。因此，下面提供的 Kotlin 代码示例将会使用协程 API 来展示如何结合 WebFlux 使用。这种方式不仅保留了异步非阻塞的优势，还让代码逻辑更加直观和易于理解。

### 编程模型

`spring-web` 模块包含了 Spring WebFlux 所基于的响应式基础，包括 HTTP 抽象、支持服务器的 Reactive Streams 适配器、编解码器以及一个可与 Servlet API 相比但具有非阻塞契约的核心 WebHandler API。

在此基础上，Spring WebFlux 提供了两种编程模型的选择：

1. **注解控制器**：这种模式与 Spring MVC 保持一致，并基于相同的来自 `spring-web` 模块的注解。Spring MVC 和 WebFlux 控制器都支持响应式（Reactor 和 RxJava）返回类型，因此在某些情况下区分它们可能并不容易。一个显著的区别是，WebFlux 还支持响应式的 `@RequestBody` 参数。

2. **函数式端点**：这是一种基于 lambda 表达式的轻量级函数式编程模型。你可以将它视为一个小库或一套应用程序可以用来路由和处理请求的工具集。与注解控制器的主要区别在于，在函数式端点中，应用程序从头到尾负责请求的处理，而不是通过注解声明意图并等待回调。

这两种编程模型各有优势，选择哪一种取决于具体的应用场景和个人偏好。注解控制器更适合那些习惯于传统 MVC 编程模型的开发者，而函数式端点则为追求更灵活、更直接控制的应用提供了一种简洁且强大的方式。无论选择哪种模型，Spring WebFlux 都提供了必要的基础设施来构建高性能、响应式的 web 应用程序。

### 适用性
#### Spring MVC 或 WebFlux？

这是一个自然而然会问的问题，但这个问题实际上建立在一个不准确的二分法之上。实际上，Spring MVC 和 WebFlux 共同作用以扩展可用选项的范围。两者设计时考虑到了彼此之间的连续性和一致性，它们可以并存，且来自任何一方的反馈都有利于双方的发展。

我们建议您考虑以下具体点：

- 如果您的 Spring MVC 应用程序运行良好，则无需更改。命令式编程是编写、理解和调试代码最简单的方式。由于历史原因，大多数库都是阻塞式的，因此您可以选择最多的库。

- 如果您已经在寻找一个非阻塞的 web 栈，Spring WebFlux 提供了与该领域其他选项相同的执行模型优势，并提供了服务器（Netty、Tomcat、Jetty、Undertow 和 Servlet 容器）、编程模型（注解控制器和函数式 web 端点）以及响应式库（Reactor、RxJava 或其他）的选择。

- 如果您对用于 Java 8 lambda 或 Kotlin 的轻量级、函数式 web 框架感兴趣，可以使用 Spring WebFlux 函数式 web 端点。对于那些可以从更高的透明度和控制中受益的小型应用程序或微服务来说，这也是一个不错的选择。

- 在微服务架构中，您可以混合使用具有 Spring MVC 或 Spring WebFlux 控制器的应用程序，或者使用 Spring WebFlux 函数端点。两个框架都支持基于相同注解的编程模型，这使得在重用知识的同时更容易为特定任务选择合适的工具。

- 评估应用程序的一个简单方法是检查其依赖项。如果您有阻塞持久化 API（如 JPA、JDBC）或要使用的网络 API，那么至少对于常见的架构而言，Spring MVC 是最佳选择。技术上讲，在 Reactor 和 RxJava 上进行单独线程的阻塞调用是可行的，但这并不会充分利用非阻塞 web 栈的优势。

- 如果您的 Spring MVC 应用程序中有对远程服务的调用，请尝试使用响应式 WebClient。您可以直接从 Spring MVC 控制器方法返回响应类型（Reactor、RxJava 或其他）。每次调用的延迟越大，或调用间的相互依赖越强，收益就越显著。Spring MVC 控制器也可以调用其他响应式组件。

- 如果您的团队规模较大，请记住转向非阻塞、函数式和声明式编程的学习曲线较为陡峭。一种实际的开始方式而不进行全面切换是使用响应式 WebClient。除此之外，从小处着手并衡量收益。我们预计，对于广泛的应用程序而言，这种转变是不必要的。如果您不确定要寻找哪些好处，请从了解非阻塞 I/O 工作原理（例如，单线程 Node.js 中的并发）及其效果开始学习。

### 服务器

Spring WebFlux 支持在 Tomcat、Jetty、Servlet 容器以及非 Servlet 运行时如 Netty 和 Undertow 上运行。所有服务器都被适配到一个低级别的通用 API，从而确保可以在不同服务器上支持更高层次的编程模型。

Spring WebFlux 并没有内置的功能来启动或停止服务器。然而，通过 Spring 配置和 WebFlux 基础设施组装应用程序，并用几行代码运行它是很容易实现的。

Spring Boot 提供了一个 WebFlux 启动器，可以自动完成这些步骤。默认情况下，该启动器使用 Netty，但只需更改 Maven 或 Gradle 依赖项即可轻松切换到 Tomcat、Jetty 或 Undertow。Spring Boot 默认选择 Netty 是因为它在异步、非阻塞领域中应用更为广泛，并允许客户端和服务器共享资源。

Tomcat 和 Jetty 可以与 Spring MVC 和 WebFlux 一起使用。但是需要注意的是，它们的使用方式非常不同。Spring MVC 依赖于 Servlet 的阻塞 I/O，并允许应用程序在需要时直接使用 Servlet API。相反，Spring WebFlux 使用 Servlet 的非阻塞 I/O，并通过一个低级别的适配器使用 Servlet API，而不是直接暴露给用户使用。强烈建议不要在 WebFlux 应用程序的上下文中映射 Servlet 过滤器或直接操作 Servlet API。由于上述原因，在同一上下文中混合使用阻塞 I/O 和非阻塞 I/O 将导致运行时问题。

对于 Undertow，Spring WebFlux 直接使用 Undertow API 而不通过 Servlet API。这种方式为开发者提供了更多的灵活性，同时也保证了性能和效率，特别是在处理高并发请求时。这种架构设计使得 Spring WebFlux 能够更好地适应不同的部署环境和技术栈，满足多样化的开发需求。

### 性能

性能具有多种特性和含义。响应式和非阻塞通常并不会让应用程序运行得更快。在某些情况下，它们可能会——例如，使用 `WebClient` 并行执行远程调用时。然而，以非阻塞方式完成任务通常需要更多的工作量，这可能会略微增加所需的处理时间。

响应式和非阻塞的主要预期收益在于能够通过少量的固定线程和更少的内存来实现扩展。这使得应用程序在负载下更具弹性，因为它们能够以更可预测的方式进行扩展。然而，要观察到这些优势，您需要具备一定的延迟（包括缓慢且不可预测的网络 I/O 的混合）。在这种场景下，响应式栈开始展现其优势，而这些差异可能会非常显著。

### 并发模型

Spring MVC 和 Spring WebFlux 都支持注解控制器，但在并发模型以及对阻塞和线程的默认假设方面存在关键差异。

在 Spring MVC（以及一般的 Servlet 应用程序中），假设应用程序可以阻塞当前线程（例如，进行远程调用时）。因此，Servlet 容器使用大型线程池来吸收请求处理过程中可能出现的阻塞情况。

而在 Spring WebFlux（以及一般的非阻塞服务器）中，假设应用程序不会阻塞。因此，非阻塞服务器使用一个小的、固定大小的线程池（事件循环工作者）来处理请求。

“扩展性”与“少量线程”这两个概念听起来可能相互矛盾，但是由于永远不会阻塞当前线程（而是依赖回调机制），这意味着您不需要额外的线程来吸收阻塞调用。这种方式不仅提高了资源利用率，还使得系统能够在高负载情况下以更可预测的方式扩展性能，尤其适用于那些涉及大量并发请求和复杂网络 I/O 的应用场景。通过避免线程阻塞，非阻塞服务器能够更高效地利用有限的计算资源，从而实现更好的伸缩性和响应能力。

### 调用阻塞API

如果您确实需要使用阻塞库怎么办？Reactor 和 RxJava 都提供了 `publishOn` 操作符，允许在不同的线程上继续处理。这意味着有一个简单的解决方案。然而，请记住，阻塞API并不适合这种并发模型。

#### 可变状态

在 Reactor 和 RxJava 中，您通过操作符声明逻辑。在运行时，会形成一个响应式管道，在其中数据以一系列独立的阶段顺序处理。这样做的一个关键好处是它使应用程序无需保护可变状态，因为管道中的应用代码不会被并发调用。

#### 线程模型

在运行 Spring WebFlux 的服务器上，您应该预期看到哪些线程？

在一个“纯”Spring WebFlux 服务器上（例如，没有数据访问或其他可选依赖），您可以预期有一个用于服务器本身的线程和几个用于请求处理的线程（通常与 CPU 核心数相同）。然而，Servlet 容器可能会启动更多的线程（例如，在 Tomcat 上为 10 个线程），以支持 Servlet（阻塞）I/O 和 Servlet 3.1（非阻塞）I/O 的使用。

响应式的 WebClient 以事件循环风格运行。因此，您可以看到与此相关的少量固定数量的处理线程（例如，使用 Reactor Netty 连接器时的 reactor-http-nio-）。然而，如果 Reactor Netty 同时用于客户端和服务端，默认情况下两者会共享事件循环资源。

Reactor 和 RxJava 提供了称为调度器（Schedulers）的线程池抽象，可以与 `publishOn` 操作符一起使用，以切换到不同的线程池进行处理。这些调度器的名字暗示了特定的并发策略——例如，“parallel”（针对有限数量线程的 CPU 密集型工作）或“elastic”（针对拥有大量线程的 I/O 密集型工作）。如果您看到了这样的线程，意味着某些代码正在使用特定的线程池调度策略。

数据访问库和其他第三方依赖也可能创建并使用自己的线程。

#### 配置

Spring 框架不提供启动和停止服务器的支持。要配置服务器的线程模型，您需要使用服务器特定的配置 API，或者，如果您使用 Spring Boot，则检查每个服务器的 Spring Boot 配置选项。您可以直接配置 WebClient。对于所有其他库，请参阅各自的文档。这确保了可以根据具体需求灵活调整服务器和客户端的行为，同时充分利用响应式编程的优势。